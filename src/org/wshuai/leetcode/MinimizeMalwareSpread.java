package org.wshuai.leetcode;

import java.util.*;

/**
 * Created by Wei on 11/15/19.
 * #924 https://leetcode.com/problems/minimize-malware-spread/
 */
public class MinimizeMalwareSpread {

	// union find
	public int minMalwareSpread(int[][] graph, int[] initial) {
		int N = graph.length;
		int[] root = new int[N];
		int[] rank = new int[N];
		for(int i = 0; i < N; i++){
			root[i] = i;
			rank[i] = 1;
		}
		for(int i = 0; i < N; i++){
			for(int j = 0; j < N; j++){
				if(graph[i][j] == 0 || i == j){
					continue;
				}
				int ri = find(i, root);
				int rj = find(j, root);
				if(ri == rj){
					continue;
				}
				if(rank[ri] > rank[rj]){
					root[rj] = ri;
					rank[ri] += rank[rj];
				}else{
					root[ri] = rj;
					rank[rj] += rank[ri];
				}
			}
		}
		// find the group with maximum number nodes that
		// only contains one infected node, if we can't, then simply return
		// the smallest index since there will be no improvement no matter
		// which node we pick to fix.
		Map<Integer, List<Integer>> map = new HashMap<>();
		int min = initial[0];
		map.put(root[min], new ArrayList<>());
		map.get(root[min]).add(min);
		for(int i = 1; i < initial.length; i++){
			min = Math.min(initial[i], min);
			int r = root[initial[i]];
			map.putIfAbsent(r, new ArrayList<>());
			map.get(r).add(initial[i]);
		}
		int max = -1;
		int res = -1;
		for(int i = 0; i < N; i++){
			if(root[i] == i && map.containsKey(i)
					&& map.get(i).size() == 1 && rank[i] > max){
				max = rank[i];
				res = map.get(i).get(0);
			}
		}
		return res == -1 ? min : res;
	}

	private int find(int i, int[] root){
		if(i != root[i]){
			root[i] = find(root[i], root);
		}
		return root[i];
	}

	// DFS
	public int minMalwareSpreadDFS(int[][] graph, int[] initial) {
		int N = graph.length;
		boolean[] visited = new boolean[N];
		Set<Integer> set = new HashSet<>();
		Arrays.sort(initial);
		int max = -1;
		int res = -1;
		for(int i : initial){
			set.add(i);
		}
		for(int i : initial){
			if(!visited[i]){
				visited[i] = true;
				int count = dfs(i, graph, visited, set);
				if(count > max){
					max = count;
					res = i;
				}
			}
		}
		return max == -1 ? initial[0] : res;
	}

	private int dfs(int i, int[][] g, boolean[] v, Set<Integer> s){
		int count  = 1;
		for(int j = 0; j < g[i].length; j++){
			if(g[i][j] == 1 && !v[j]){
				v[j] = true;
				if(s.contains(j)){
					count += -1_000;
				}
				count += dfs(j, g, v, s);
			}
		}
		return count;
	}

	// BFS
	public int minMalwareSpreadBFS(int[][] graph, int[] initial) {
		int max = -1;
		int N = graph.length;
		Map<Integer, Integer> map = new HashMap<>();
		Set<Integer> infected = new HashSet<>();
		boolean[] visited = new boolean[N];
		Arrays.sort(initial);
		for(int i : initial){
			infected.add(i);
		}
		LinkedList<Integer> queue = new LinkedList<>();
		for(int i : initial){
			int cnt = 0;
			int inf = 0;
			int nid = -1;
			if(!visited[i]){
				visited[i] = true;
				queue.offerLast(i);
				while(!queue.isEmpty()){
					int curr = queue.pollFirst();
					cnt++;
					if(infected.contains(curr)){
						inf++;
						nid = curr;
					}
					for(int j = 0; j < N; j++){
						if(graph[curr][j] == 1 && !visited[j]){
							visited[j] = true;
							queue.offerLast(j);
						}
					}
				}
			}
			if(inf == 1){
				if(map.getOrDefault(cnt, 500) > nid){
					map.put(cnt, nid);
				}
				max = Math.max(max, cnt);
			}
		}
		return max == -1 ? initial[0] : map.get(max);
	}
}
